## JVM

### 一、整体架构

![第02章_JVM架构-简图](img\第02章_JVM架构-简图.jpg)

### 二、详细架构

![第02章_JVM架构-中](img\第02章_JVM架构-中.jpg)

### 三、类加载子系统

类加载器子系统负责从文件系统或者网络中加载Class文件，Class文件在文件头有特定的文件标识。

加载的类信息存放于方法区，除了类的信息外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。

#### 1、类加载过程

![第02章_类的加载过程](img\第02章_类的加载过程.jpg)

+ 加载

  + 通过类的全限定名获取定义类的二进制字节流。

  + 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。

  + **在内存中生成一个代表类的java.lang.Class对象**，代表方法区这个类的各种数据的访问入口。

+ 链接

  + 验证

    目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。

  + 准备

    为类变量分配内存并且设置该类变量的默认初始值，即零值。

    这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化。

    这里不会为实例变量分配初始值，类变量会分配在方法区中，而实例变量会随对象一起分配到堆中。

  + 解析

    + 将常量池内的符号引用转换为直接引用的过程。

    + 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。

    + 符号引用就是一组符号来描述所引用的目标，符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
    + 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。

+ 初始化

  + 初始化阶段就是执行类构造器方法\<clinit>的过程。
  + 此方法不需要定义，是javac编译器自动收集类中的所有**类变量的赋值动作**和**静态代码块**中的语句合并起来的。
  + 构造器方法中指令按语句在源文件中出现的顺序执行。
  + \<clinit>()不同于类的构造器。（构造器是虚拟机视角下的\<init>()）。
  + 若该类具有父类，JVM会保证子类\<clinit>()执行前，父类的\<clinit>()已经执行完毕。
  + 虚拟机必须保证一个类的\clinit>()方法在多线程下被同步加锁。

#### 2、类加载器的分类

![image-20230403132251608](img\image-20230403132251608.png)

+ 引导类加载器

  + 启动类加载器：Bootstrap ClassLoader

    + C/C++语言实现，嵌套在JVM内部。

    + 用来加载java核心库。
    + 不是继承自ClassLoader，没有父加载器。
    + 加载扩展类加载器和系统类加载器（应用程序类加载器）。
    + 出于安全考虑，只加载java、Javax、sun等开头的类。

+ 自定义类加载器

  + 扩展类加载器：Extension ClassLoader
    + Java语言编写。
    + 派生于ClassLoader类。
    + 父类加载器为启动类加载器。
    + 从java.ext.dirs系统属性所指定的目录中加载类库，或者从jdk的安装目录下的。jre/lib/ext子目录下加载类库。**用户创建的jar放在此目录也会由扩展类加载器加载**。

  + 系统类加载器（应用程序类加载器）：AppClassLoader
    + Java语言编写。
    + 派生于ClassLoader类。
    + 父类加载器为扩展类加载器。
    + 负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。
    + 是程序中默认的类加载器，一般来说，Java应用的类都是由它完成加载。
  + 用户自定义类加载器
    + 为什么要自定义类加载器？
      + 隔离加载类
      + 修改类加载的方式
      + 扩展加载源
      + 防止源码泄漏

#### 2、双亲委派机制

![image-20230403135736702](img\image-20230403135736702.png)

+ 工作原理
  + 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行。
  + 如果父类加载器还存在父类加载器则继续向上委托。
  + 如果父类加载器可以完成类加载就返回成功，父类无法加载时子类尝试自己去加载。
+ 优势
  + 避免类的重复加载。
  + 保护程序安全，防止核心API被随意篡改。

+ 沙箱安全机制

#### 3、类的主动使用和被动使用

+ 主动使用

  + 创建类的实例

  + 访问某个类或接口的静态变量，或对该静态变量赋值

  + 调用类的静态方法

  + 反射

  + 初始化一个类的子类

  + Java虚拟机启动时被标明为启动类的类

  + jdk7开始提供的动态语言支持：

    java.lang.invoke.MethodHandle实例的解析结果

    REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

+ 被动使用

  除去以上7中情况，都看作是对类的被动使用，都**不会导致类的初始化**

### 四、运行时数据区

![image-20230403141500437](img\image-20230403141500437.png)

方法区和堆区一个进程一份（线程共享），程序计数器、本地方法栈、虚拟机栈一个线程一份（线程独享）。

#### 1、程序计数器（PC寄存器）

作用：用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令。

程序计数器不会出现OOM。

#### 2、虚拟机栈

+ 每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。是线程私有的。

+ 生命周期和线程一致

+ 主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。

+ 优点：

  + 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
  + JVM直接对Java栈的操作只有两个：
    + 每个方法执行伴随着进栈
    + 执行结束后的出栈

  + 对于栈来说不存在垃圾回收问题。但是会有StackOverflow异常，可以通过-Xss设置栈大小。

+ 栈运行原理

  + 遵循“先进后出” / “后进先出”原则。
  + 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧称为当前栈帧，与当前栈帧相对应的方法就是当前方法，定义这个方法的类就是当前类。
  + 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
  + 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧。

![第05章_栈桢内部结构](img\第05章_栈桢内部结构.jpg)

##### 2.1 局部变量表

+ 也被称为局部变量数组或者本地变量表
+ **定义为一个数字数组，主要用于存储方法参数和定义在方法内部的局部变量**，这些数据类型包括各类基本数据类型、对象引用以及returnAddress类型。
+ 由于局部变量表是建立在线程的栈上，是线程私有数据，所有**不存在数据安全问题**。
+ **局部变量表所需要的容量大小是在编译期确定下来的**，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。
+ Slot
  + 局部变量表的**基本存储单位是Slot（变量槽）**，32位以内的类型只占一个Slot（包括returnAddress类型），64位的类型（long和double）占两个Slot。
  + 如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的Slot处，其余参数按照参数表顺序排列。这也是为什么static方法没有this的原因。
  + 可重复利用。

+ 说明
  + 在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
  + **局部变量表中的变量也是重要的垃圾回收根节点，只有被局部变量表中直接或间接引用的对象都不会被回收。**

补充：

+ 成员变量：在使用前都经历过默认初始化赋值
  + 类变量：类加载链接的准备阶段给变量赋默认值，初始化阶段给类变量显式赋值（静态代码块赋值）
  + 实例变量：随对象创建进行默认赋值
+ 局部变量：在使用前必须进行显式赋值，否则编译不通过。

##### 2.2 操作数栈（表达式栈）

+ 操作数栈在方法执行过程中，根据字节码指令，往栈中写入数据或者提取数据，即入栈和出栈。

  某些字节码指令将值压入操作数栈，其余字节码指令将操作数取出，使用后再将结果压入栈。比如执行复制、交换、求和等操作。

+ **如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中**，并更新程序计数器中下一条需要执行的字节码指令。

+ 栈顶缓存技术（了解）

  将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎执行效率。

##### 2.3 动态链接（**指向运行时常量池的方法引用**）

+ 每一个栈帧内部都包含一个指向**运行时常量池中该栈帧当前所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现**动态链接**。
+ 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在Class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。**

##### 2.4 方法返回地址（方法正常退出或异常退出的定义）

+ 存放**调用该方法的程序计数器**的值
+ 方法结束的两种方式
  + 正常执行退出
  + 出现未处理异常，非正常退出

+ 无论哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**调用者的程序计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址**。而通过异常退出的返回地址是要通过异常表来确定的栈帧中一般不会保存这部分信息。

本质上，方法退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、**将返回值压入调用者栈帧的操作数栈**、设置程序计数器值等，让调用者方法继续执行下去。

**正常完成出口和异常完成出口区别在于：通过异常完成出口退出的不会给上层调用者产生任何返回值。**

##### 2.5 一些附加信息

栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。

#### 3、本地方法栈

+ Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法栈的调用。
+ 也是线程私有的
+ 允许被实现成固定或者动态扩展的内存大小。（在内存溢出方面是相同的）

#### 4、堆

+ 一个Java实例只存在一个堆内存，堆是Java内存管理的核心区域。
+ 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。（大小可以调节）
+ 堆可以处于物理内存上不连续的内存空间中，但在逻辑上它应该是被视为连续的。
+ 所有线程共享堆，还可以再这里划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。
+ “几乎”所有的对象实例都在堆上分配内存（逃逸分析）。
+ 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会别移除。
+ 堆是GC执行垃圾回收的重点区域。

![第08章_堆和方法区图](img\第08章_堆和方法区图.jpg)

##### 4.1 堆的内存结构

+ Java 7及之前：新生代 + 老年代 + **永久区**
+ Java 8及之后：新生代 + 老年代 + **元空间**

​	新生代又分为 Eden 区和 Survivor 区

##### 4.2 堆空间大小的设置

+ -Xms 用于配置堆区的起始内存，等价于 -XX:InitialHeapSize
+ -Xmx 用于配置堆区的最大内存，等价于 -XX:MaxHeapSize
+ 堆内存超过 -Xmx 所指定大小时，将会抛出 OutOfMemoryError 异常。
+ 通常 -Xms 和 -Xmx 两个参数配置成相同的值，目的是为了等够在java垃圾回收机制清理完堆区后不需要重新分割计算堆区的大小，从而提升性能。
+ 默认情况，初始内存大小：物理内存大小 / 64；最大内存大小：物理内存大小 / 4。

##### 4.3 新生代与老年代

![第08章_堆空间细节](img\第08章_堆空间细节.jpg)

+ 新生代与老年代的结构占比
  + 默认 -XX:NewRatio=2，表示新生代占比1，老年代占比2，新生代占整个堆的1/3。参数可以配置。
  + -Xmn 可以配置新生代最大内存大小（一般使用默认值）。
  + 以上两个参数同时配置时以 -Xmn 为准。

+ Eden区和Survivor区结构占比 8:1:1
  + 默认-XX:SurvivorRatio=8 可以配置两个区的占比。

##### 4.4 对象分配与回收过程

![第08章_新生代对象分配与回收过程](img\第08章_新生代对象分配与回收过程.jpg)

+ 对象分配的一般情况

  + new的对象先放在Eden区。此区有大小限制。

  + 当Eden区的空间填满时，又有新对象需要分配空间，JVM垃圾回收器将对Eden区和Survivor0区进行垃圾回收（Minor GC），将其中不再被其他对象所引用的对象进行销毁。再加载新的对象放到Eden区。

  + 然后将剩余存活对象复制到Survivor1区，并且将Survivor0区和Eden区的对象给清空，并且将Survivor0区和Survivor1区交换。

  + 再次经历垃圾回收，重复上一步

  + 当幸存次数达到15次（默认）时，对象进入老年代。

    可以通过参数：-XX:MaxTenuringThreshold进行设置（0-15）

+ 对象分配的特殊情况

  ![image-20230403184138686](img\image-20230403184138686.png)

##### 4.5 Minor GC、Major GC与Full GC

JVM在进行GC时，并不是每次都会对新生代、老年代、方法区存进行回收，大部分时间回收的都是指新生代。

针对HotSpot VM的实现，它里面的GC按照回收区域分为两大类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）

+ 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：

  + 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集。
  + 老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。
    + 目前只有CMS GC会有单独收集老年代的行为。
    + **注意，很多时候Major GC会和Full GC混淆使用，需要具体分析是老年代回收还是整堆回收。**

  + 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。

    目前只有G1 GC会有这种行为。

+ 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

**新生代GC（Minor GC）触发机制**：

+ 当新生代空间不足时，就会触发Minor GC，这里的新生代指的是Eden区满，Survivor区满不会引发GC。
+ 因为Java对象多数都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
+ Minor GC会引发STW(stop the world)，暂停其他用户线程，等垃圾回收结束，用户线程才能恢复运行。

**老年代GC（Major GC / Full GC）触发机制**：

+ 出现Major GC经常会伴随至少一次的Minor GC（但非却对的，在Parallel Scavenge收集器的收集策略就有直接进行Major GC的策略选择过程）。
+ Major GC的速度一般比Minor GC慢10倍以上，STW的时间更长。
+ 如果Major GC后内存还是不足，则OOM。

**Full GC触发机制**：

+ 调用System.gc()时，系统建议执行Full GC，但不是必然执行。
+ 老年代空间不足
+ 方法区空间不足
+ 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
+ 由Eden区、Survivor0区向Survivor1区复制时，对象大小大于Survivor1区可用内存，则该对象转存到老年代，且老年代的可用内存小于该对象大小。

说明：**Full GC是开发或者调优中尽量要避免的，这样暂停时间会短一些**。

**输出详细GC日志信息**：-XX:+PrintGCDetails

![image-20230331122011936](img\image-20230331122011936.png)

##### 4.6 内存分配策略（对象提升规则）

针对不同年龄段的对象分配原则如下：

+ 优先分配到Eden区

+ 大对象直接分配到老年代

  尽量避免程序中出现过多大对象

+ 长期存活的对象分配到老年代

+ 动态对象年龄判断

  如果Survivor区中相同年龄的所有对象大小的总和大于Survivor区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

+ 空间分配担保

  在发生Minor Gc之前，虚拟机会检**查老年代最大可用的连续空间是否大于新生代所有对象的总空间**。

  + 如果大于，则此次Minor GC是安全的
  + 如果小于，则虚拟机会查看-XX : HandlePromotionFailure设置值是否允许担保失败。
    + 如果HandlePromotionFailure = true， 那么会继续**检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**。
      + 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的;
      + 如果小于，则改为进行一次Full GC。
    + 如果HandlePromotionFailure = false， 则改为进行一次Full GC。

  在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为只要**老年代的连续空间大于新生代对象总大小**或者**历次晋升的平均大小就会进行Minor GC**， 否则将进行Full GC。

##### 4.7 线程私有的缓冲区 TLAB

![第08章_TLAB](img\第08章_TLAB.jpg)

+ 为什么会有TLAB？
  + 堆区是线程共享区域，任何线程都可以访问到堆区的共享数据
  + 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
  + 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

+ 什么是TLAB？
  + 从内存模型而不是垃圾收集的角度，对Eden区进行继续进行划分，JVM为**每个线程分配了一个私有缓存区域**，它包含在Eden区空间内。
  + 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此可以将这种内存分配方式称之为**快速分配策略**。
  + OpenJDK衍生出来的JVM都提供了TLAB的设计。

+ 说明
  + 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选**。
  + 通过 -XX:UseTLAB 配置是否开启TLAB空间，默认开启。
  + 默认情况下，TLAB空间的内存非常小，**仅占有整个Eden区的1%**，可以通过 -XX:TLABWasteTargetPercent 配置TLAB空间所占Eden区的百分比大小。
  + 一旦对象在TLAB空间分配内存失败时，JVM就尝试着通过**使用加锁机制**确保数据操作的原子性，从而直接在Eden区中分配内存。

+ 对象分配过程TLAB

  ![第08章_对象分配过程](img\第08章_对象分配过程.jpg)

##### 4.8 逃逸分析（并不成熟）

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是**如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

**逃逸分析的基本行为就是分析对象动态作用域**：

+ 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。

+ 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他方法中。

  ```java
  // 针对StringBuffer stringBuffer而言认为发生逃逸
  public static StringBuffer createString() {
          StringBuffer stringBuffer = new StringBuffer();
          stringBuffer.append("string");
          stringBuffer.append("Buffer");
          return stringBuffer;
      }
  // 针对StringBuffer stringBuffer而言认为没有发生逃逸
  public static String createString() {
          StringBuffer stringBuffer = new StringBuffer();
          stringBuffer.append("string");
          stringBuffer.append("Buffer");
          return stringBuffer.toString();
      }
  ```

**基于逃逸分析的代码优化**：

+ **栈上分配**（支持方法逃逸，不支持线程逃逸）

  将堆分配转化为栈分配。

  ```java
  /**
   * -Xms128m -Xmx128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
   */
  public class Test {
  
      public static void main(String[] args) {
  
          long start = System.currentTimeMillis();
          for (int i = 0; i < 10000000; i++) {
              test();
          }
          long end = System.currentTimeMillis();
          System.out.println("Test took " + (end - start) + "ms");
          try {
              Thread.sleep(10000000);
          } catch (InterruptedException exception) {
              exception.printStackTrace();
          }
      }
  
      public static void test(){
          User user = new User();// 未发生逃逸
      }
  
  }
  
  class User{}
  ```

  + 关闭逃逸分析：-XX:-DoEscapeAnalysis

    发生GC且内存中有10000000个User实例，耗时长

  ![image-20230403221551127](img\image-20230403221551127.png)

  ![image-20230403220751929](img\image-20230403220751929.png)

  + 开启逃逸分析：-XX:+DoEscapeAnalysis

    未发生GC且内存中没有10000000个User实例，耗时短

  ![image-20230403221631988](img\image-20230403221631988.png)

  ![image-20230403220906742](img\image-20230403220906742.png)

+ **同步省略**

  即锁消除

  ```java
  //锁消除前 咱也不知道什么样的人能写出这样的代码。。。
  public void fun1() {
          User user = new User();
          synchronized (user) {
              System.out.println(user);
          }
      }
  
  // 锁消除后
  public void fun2() {
          User user = new User();
          System.out.println(user);
      }
  ```

  虽然第一个方法有锁消除机制，但是字节码中依然是有锁的，只有在运行时才会被优化掉。

  ![image-20230403223137342](img\image-20230403223137342.png)

+ **分离对象或标量替换**

  在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来替换，这个过程就是标量替换。

  标量替换参数配置：-XX:EliminateAllocations（默认开启），运行将对象打散分配在栈上。

  ```java
  public class Test {
      public static void main(String[] args) {
          test();
      }
  
      // 标量替换前
      public static void test() {
          User user = new User("user", 3);
          System.out.println("name: " + user.name + "," + "age: " + user.age);
      }
      
      // 标量替换后
      public static void test2() {
          String name = "user";
          int age = 3;
          System.out.println("name: " + name + "," + "age: " + age);
      }
  }
  
  class User {
      public String name;
      public int age;
  
      public User(String name, int age) {
          this.name = name;
          this.age = age;
      }
  }
  ```

**PS：经过测试发现开启逃逸分析，关闭变量替换后上面栈上分配的效果就没了，所以其实真正起到作用的是标量替换。**

**所以目前来说“对象一定都分配在堆上”这句话是正确的！！！？？？**

#### 5、方法区

栈、堆和方法区的关系：

![image-20230404113556851](img\image-20230404113556851.png)

**方法区看作是一块独立于Java堆的内存空间。（Non-Heap 非堆）**

**方法区大小配置**：

+ jdk7及之前（永久代）
  + -XX:PermSize 配置初始空间，默认值20.75M
  + -XX:PermSize 设定最大分配空间，32位默认64M，64位默认82M
  + 当JVM加载类信息容量超过这个值，会报异常 OutOfMemoryError:PermGenspace
+ jdk及之后（元空间）
  + -XX:MetaspaceSize，默认值依赖于平台，建议设置一个较高的值。
  + -XX:MaxMetaspaceSize，默认值依赖于平台，默认即可。
  + 异常 OutOfMemoryError:Metaspace

##### 5.1 方法区存储什么（后续部分变化）

用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等。

+ 类型信息

  对每个加载的类型（类Class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储一下类型信息：

  + 这个类型的完整有效名称（包名.类名）
  + 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
  + 这个类型的修饰符（public，abstract，final的某个子集）
  + 这个类型直接接口的一个有序列表

  域（Field）信息（字段）

  + JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
  + 域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）

  方法（Method）信息，JVM必须在保存所有方法的以下信息，包括声明顺序。

  + 方法名称

  + 方法的返回类型（或void）

  + 方法参数的数量和类型（按顺序）

  + 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）

  + 方法的字节码、操作数栈、局部变量表及大小（abstract和native方法除外）

  + 异常表（abstract和native方法除外）

    每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

  non-final

  static 修饰的字段编译时不会赋值，在类加载时链接的准备阶段赋默认值，真正赋值初始化阶段。

  static final 修饰的字段编译时就已经赋值。

##### 5.2 运行时常量池和常量池

方法区内部包含了运行时常量池；字节码文件内部包含了常量池。

+ 常量池

  一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表，包括各种字面量和对类型、域和方法的**符号引用**

  存储的数据类型：

  + 数量值
  + 字符串值
  + 类型引用
  + 字段引用
  + 方法引用

  常量池可以看做是一张表，虚拟机指令根据这张常量池表找到要执行的类名、方法名、参数类型、字面量等类型。

+ 运行时常量池
  + 常量池表时Class文件的一部分，**用于存放编译期生成的各种字面量与符号引用**，这部分内容将在**类加载后存放到方法区的运行时常量池**中。
  + JVM为每个已加载的类型（类或接口）都维护一个常量池，池中的数据像数组项一样，通过**索引访问**。
  + 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址，这里换为真实地址。运行时常量池相对Class文件中的常量池的重要特征：**具备动态性**。
  + 当创建类型的运行时常量池是，如果所需内存空间超过方法区所能提供的最大值，则JVM抛出OutOfMemoryError异常。

##### 5.3 方法区的演进

只有Hotspot才有永久代！

Hotspot中方法区的变化：

+ jdk1.6及之前：有永久代，静态变量存放在永久代上
+ jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中
+ jdk1.8及之后：无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中

##### 5.4 方法区的垃圾收集

方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型

+ 类型回收的条件（可能被回收）
  + 该类所有实例都已经被回收（说明堆中也不存在该类的派生子类）
  + 加载该类的类加载器已经被回收
  + 该类对应的java.lang.Class对象没有任何地方被引用，无法再任何地方通过反射访问该类的方法

### 五、本地方法接口

Nation Method就是一个Java调用的非Java代码的接口。

### 六、执行引擎

![image-20230404152305383](img\image-20230404152305383.png)

### 七、对象

#### 1、对象的实例化

![第10章_对象的实例化](img\第10章_对象的实例化.jpg)

#### 2、对象的内存布局

![第10章_内存布局](img\第10章_内存布局.jpg)

![第10章_图示对象的内存布局](img\第10章_图示对象的内存布局.jpg)

#### 3、对象的访问方式

![第10章_对象访问定位](img\第10章_对象访问定位.jpg)

![第10章_方式1：句柄访问](img\第10章_方式1：句柄访问.jpg)

![第10章_方式2：使用直接指针访问](img\第10章_方式2：使用直接指针访问.jpg)

### 八、String

#### 1、String的基本特性

+ 字符串，使用一对""引起来表示
+ String声明为final，不可以被继承
+ String实现了Serializable接口（支持序列化）、Comparable接口（可比较大小）
+ String在jdk8及之前内部定义了final char[] value用于存储字符串数据，jdk9是改为byte[]
+ String代表**不可变**的字符序列
+ 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。

+ **字符串常量池不会存储相同内容的字符串**
  + 底层是一个固定大小的hashtable
  + 配置参数：-XX:StringTableSize
  + jdk8开始配置最小值为1009

#### 2、String的内存分配

字符串常量池，jdk6及之前在永久代，之后在堆中

### 九、垃圾回收















## JUC 



## 设计模式



## 数据结构和算法



## RPC



## Dubbo

